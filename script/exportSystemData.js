/**
 * @author aMediocreDad
 * @copyright Copyright (c) 2021. You are free to use this software for any purpose without fee or charge.
 *
 * @description:
 *  ***********************************
 *  * This script is intended to be   *
 *  * cut and pasted into the console *
 *  * of foundry                      *
 *  ***********************************
 */

/**
 *
 * @constant
 * @type {Object.<string, string>}
 * @description A dictionary used for referencing the entities you'd like to have exported.
 */
const entityTypes = {
	Actor: "actors",
	Item: "items",
	JournalEntry: "journal",
	RollTable: "tables",
	Scene: "scenes",
};

/**
 *
 * 	@param {Object.<string, string>} types is supplied the type-list (usually the one declared above).
 *	@return {Object.<string, unknown>} A nested object of all folders and entities in the world. Folder -> Children -> Content.
 */
async function getDirectories(types) {
	const workingTree = {};
	for (const [typeName, type] of Object.entries(types)) {
		workingTree[typeName] = await game[type].directory.tree;
	}
	return workingTree;
}

/**
 *
 * @description Sets the flags of any entity that you later want to link upon import. E.g. rolltable results, journal entry sorting, or scene notes / tokens.
 */
async function setEntityFlags() {
	const journals = game.journal.contents;
	for await (const journal of journals) {
		await setProperty(
			journal,
			"data.flags.bh-content.folder.sort",
			journal.data.sort
		);
	}
}

/**
 *
 * @param {Object.<string, any>} node A node from the object generated by _getDirectories_.
 * @param {Object.<string, string>} manifestEntry A node in the manifest entry. This object is recursively generated by this function.
 * @param {Object.<string, any>} modulePack Foundry object generated in _createdCompendiums_.
 * @param {String} type Foundry Entity type supplied by referencing the _entityTypes_ object.
 * @description This function recurses upon itself by adding content to the Foundry compendium packs, then generating nodes referencing the created content and their **World**.entity_Id in _manifestEntry_.
 */
async function dirtyWork(node, manifestEntry, modulePack, type) {
	for (const [key, entries] of Object.entries(node)) {
		switch (key) {
			case "content":
				if (entries.length > 0) {
					manifestEntry["entities"] = {};
					const preparedEntries = entries.map((e) => e.data);
					const cls = await getDocumentClass(type);
					const createdEntity = await cls.createDocuments(
						preparedEntries,
						{ pack: modulePack.collection, keepId: true }
					);
					if (entries.length === 1) {
						manifestEntry["entities"][createdEntity[0].data._id] =
							createdEntity[0].data.name;
					} else if (entries.length > 1) {
						for await (const entry of createdEntity) {
							manifestEntry["entities"][entry.data._id] =
								entry.data.name;
						}
					} else {
						throw console.error("Failed to add entry to manifest.");
					}
				}
				break;
			case "children":
				for (const folder of entries) {
					manifestEntry[folder.data.name] = {
						content: {},
						sorting: folder.data.sorting ?? "a",
						sort: folder.data.sort ?? null,
					};
					await dirtyWork(
						folder,
						manifestEntry[folder.data.name].content,
						modulePack,
						type
					);
				}
				break;
		}
	}
}

/**
 *
 * @param {String} moduleLabel Label/Title of a top level folder in a given entity type.
 * @param {String} entityType The entity type, used in generating the name of the compendium.
 * @returns A compendium with a name based on the label and the type (to make sure the same root folder name can be reused across entitytypes).
 */
async function createCompendiums(moduleLabel, entityType) {
	moduleLabel = moduleLabel + " " + [entityTypes[entityType]];
	const moduleName = moduleLabel
		.replace(/[^A-z0-9\s]/gi, "")
		.replace(/\s/gi, "-")
		.toLowerCase();
	// await game.packs.map(async (pack) =>
	// 	pack.metadata.package === "world"
	// 		? await pack.deleteCompendium()
	// 		: false
	// );
	const createdCompendium = await CompendiumCollection.createCompendium({
		name: moduleName,
		label: moduleLabel,
		entity: entityType,
	});
	return createdCompendium;
}

/**
 *
 * @param {Array<string>} entityToCheck An array of names of a given entity type.
 * @param {String} type The supplied entity type that matches {@link entityToCheck}.
 * @returns {Function} Console logs OK!
 * @description Looks for duplicates in a given entity type. It is called before the rest of the script runs.
 */
async function truthFinder(entityToCheck, type) {
	const uniqueNames = [...new Set(entityToCheck)];
	if (uniqueNames.length !== entityToCheck.length) {
		const warning = `Found duplicates in ${type}:
		 `;
		const duplicates = [...entityToCheck];
		uniqueNames.forEach((item) => {
			const i = duplicates.indexOf(item);
			duplicates = duplicates
				.slice(0, i)
				.concat(duplicates.slice(i + 1, duplicates.length));
		});
		throw console.warn(warning, duplicates);
	} else {
		const green = `%c${type.replace(
			type[0],
			type[0].toUpperCase()
		)} contain no duplicates.`;
		return console.info(green, "color:green");
	}
}

/**
 *
 * @description Ties all functions together, looping over each entitytype in workingTree, and finally printing the manifest.json.
 * If you are exporting several "modules" at once you have to split the resulting manifest.json (I intend to do this automatically at some point);
 */
(async function exportModules() {
	Object.values(entityTypes).forEach(async (type) => {
		const entityToCheck = await game[type].contents.map(({ name }) => name);
		await truthFinder(entityToCheck, type).catch((e) => {
			throw console.error("Found duplicates, exiting!", e);
		});
	});
	for await (pack of game.packs) {
		pack.metadata.package === "world"
			? await pack.deleteCompendium()
			: null;
	}
	await setEntityFlags();
	const manifestInitialized = {};
	const workingTree = await getDirectories(entityTypes);
	async function loop() {
		for (const entityType in workingTree) {
			manifestInitialized[entityType] = {};
			const rootDir = workingTree[entityType].children;
			if (rootDir.length !== 0) {
				for (const moduleFolder of rootDir) {
					const moduleFolderName = moduleFolder.data.name;
					const node = moduleFolder;
					manifestInitialized[entityType][moduleFolderName] = {
						content: {},
						sorting: moduleFolder.data.sorting ?? "a",
						sort: moduleFolder.data.sort ?? null,
					};
					const manifestEntry =
						manifestInitialized[entityType][moduleFolderName]
							.content;
					const createdComp = await createCompendiums(
						moduleFolderName,
						entityType
					).catch((e) => {
						error = "Couldn't create compendiums. " + e;
						throw error;
					});
					await dirtyWork(
						node,
						manifestEntry,
						createdComp,
						entityType
					);
				}
			}
		}
		return manifestInitialized;
	}
	const finalManifest = await loop().catch((e) => {
		const error = console.error("Looks like something broke:\n", e);
		throw error;
	});
	const print = JSON.stringify(finalManifest);
	saveDataToFile(print, JSON, "manifest.json");
})();
