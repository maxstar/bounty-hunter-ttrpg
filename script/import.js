// Set global module variables.
export const moduleKey = "bounty-hunter-ttrpg"; // Module name. Important that this one is the exact same as the name of the module
const moduleTitle = "Bounty Hunter TTRPG"; // Module Title, is not referenced beyond giving a title to HTML dialog, so can be anything
const packageManifest = "data-manifest.json"; // This is the manifest generated by the export script. Not necessary to alter unless the filename has been manually altered.
const sceneToActivate = "Welcome!"; // The name of the scene you want to display after import.
const welcomeJournalEntry = "Welcome!"; // The name of a journal entry you want to display after import.
const moduleFlag = "bh-content"; // The module specific flag given in the export script
const requiredSystemVersion = "1.0.0";
export const moduleVersion = "1.0.0";
const moduleFolderNameDict = {
	"Adversaries actors": "Adversaries",
	"Starships actors": "Starships",
	"Skills items": "Skills",
	"Abilities items": "Abilities",
	"Gear items": "Gear",
	"Starship Components items": "Starship Components",
	"Bounty Hunter TTRPG scenes": "Bounty Hunter TTRPG",
	"Welcome journal": "Welcome",
}; // This object is intended to be used to conver the module pack names back to "Folder names". It is referenced against the manifest.json so it is important that the key is the pack name and the value is the folder name.

// Setting Hooks to easily interact with the importing of the compendiums.
Hooks.on("init", () => {
    game.settings.register(moduleKey, "imported", {
        name: "Imported Compendiums",
        scope: "world",
        config: false,
        type: Boolean,
        default: false,
    });
    game.settings.registerMenu(moduleKey, "import", {
        name: "Import Compendiums",
        label: "Start importing the compendiums!",
        hint: "This will create new folders and import all the compendiums from the module. Be aware that duplicates will appear if some of the content in these modules already exists in your World!",
        type: ImportFormWrapper,
        restricted: true,
    });
});

// Hook opens Dialog on first launch prompting for import.
Hooks.on("ready", () => {
    if (!game.settings.get(moduleKey, "imported") && game.user.isGM) {
        new ModuleImportDialog().render(true);
    }
});

// class required by the registerMenu method.
class ImportFormWrapper extends FormApplication {
    render() {
        new ModuleImportDialog().render(true);
    }
}

/**
 * @description This class is responsible for presenting a Dialog that prompts for importing the content of the modules.
 * @extends Dialog A FormApplication class in Foundry VTT responsible for creating pop-up dialogues.
 */
export class ModuleImportDialog extends Dialog {
	constructor() {
		super({
			title: `Import ${moduleTitle}`,
			content: `<div style="height: 660px;font-size:var(--font-size--small);">
            <b>Start importing all the content in ${moduleTitle}?</b>
            <p>This will import all the module packs into your world and sort them into folders</p>
            <ul style="font-weight:bold;">
            <li>Actors (NPCs, Monsters)</li>
            <li>Starships</li>
            <li>Items, ranging from Gear to Skills, and Abilities</li>
            </ul>
            <p>Doing this may create duplicates.<br><strong>Backup and save your world data before importing!</strong></p>
            <br>
            <hr>
            <br>
            <p class="bh-special">All rights to content provided with this system belong to Guy Sclanders (aka GreatGM) and are distributed with his permission.</p>
						</div>`,
			buttons: {
				initialize: {
					label: "Import",
					callback: async () => {
						await this.checkVersion().catch(() => {
							throw console.warn("Version check failed.");
						});
						console.time("Importing");
						await new ModuleImportDialog()
							.prepareModule()
							.catch((e) => {
								let error = console.error(
									"Failed to initialize module",
									e
								);
								throw error;
							});
						await this.renderWelcome();
						game.settings.set(moduleKey, "imported", true);
						ui.notifications.notify("Import complete. No Issues.");
						console.timeEnd("Importing");
					},
				},
				cancel: {
					label: "Cancel",
					callback: () => {
						game.settings.set(moduleKey, "imported", true);
						ui.notifications.notify(
							"Canceled importing content. You can always import the compendiums through the system's settings menu."
						);
					},
				},
			},
		});
		this.imported = {
			Actor: {},
			Item: {},
			JournalEntry: {},
			RollTable: {},
			Scene: {},
		};
	}
	async prepareModule() {
		const manifest = await this.readManifest(packageManifest);
		const modulePacks = await game.system.packs;
		console.warn("Starting import of: ", moduleTitle);
		ui.notifications.notify(
			`Starting import of: ${moduleTitle}. Hold on, this could take a while...`
		);
		await this.importModule(manifest, modulePacks);
		await this.performFlagUpdates();
	}
	async importModule(manifest, modulePacks) {
		return Promise.all(
			modulePacks.map(async (p) => {
				const pack = await game.packs
					.get(moduleKey + "." + p.name)
					.getDocuments();
				const type = p.entity;
				if (type !== "Playlist" && type !== "Macro") {
					const moduleFolderName = moduleFolderNameDict[p.label];
					const moduleFolderId = await Folder.create({
						name: moduleFolderName,
						type: type,
						parent: null,
						sort: manifest[type][moduleFolderName].sort || null,
						sorting:
							manifest[type][moduleFolderName].sorting || "a",
					});
					const manifestEntity =
						manifest[type][moduleFolderName].content;
					await this.importFromManifest(
						manifestEntity,
						pack,
						type,
						moduleFolderId.data._id
					);
				} else if (type === "Playlist") {
					const uniquePlaylists = pack.filter((p) => {
						if (
							!game.playlists.find(
								(n) => n.data.name === p.data.name
							)
						)
							return p;
					});
					Playlist.create(uniquePlaylists.map((p) => p.data));
				} else {
					const uniqueMacros = pack.filter((p) => {
						if (
							!game.macros.find(
								(n) => n.data.name === p.data.name
							)
						)
							return p;
					});
					Macro.create(uniqueMacros.map((p) => p.data));
				}
				return true;
			})
		);
	}
	async importFromManifest(manifest, pack, type, parent) {
		if (manifest.parent) {
			parent = manifest.parent;
			delete manifest.parent;
		}
		for await (const [key, item] of Object.entries(manifest)) {
			if (key !== "entities") {
				const folder = await Folder.create({
					name: key,
					type: type,
					parent: parent || null,
					sort: item.sort || null,
					sorting: item.sorting || "a",
				});
				const pushParent = Object.values(item);
				await pushParent.forEach((child) => {
					if (child && typeof child === "object")
						child.parent = folder.data._id;
				});
				await this.importFromManifest(item.content, pack, type);
			} else if (key === "entities") {
				try {
					const entityData = Object.keys(item).reduce(
						(result, identifier) => {
							const entity = pack.filter(
								(e) => e.data._id === identifier
							);
							return [...result, entity[0].data];
						},
						[]
					);
					for await (const entry of entityData) {
						entry._source.folder = parent || null;
					}
					const cls = getDocumentClass(type);
					const createdEntities = await cls.createDocuments(
						entityData,
						{ keepId: true }
					);
					if (Array.isArray(createdEntities)) {
						for await (const entry of createdEntities) {
							this.imported[type][entry.data.name] = entry;
						}
					} else {
						this.imported[type][createdEntities.data.name] =
							createdEntities;
					}
				} catch (e) {
					console.warn("Could not create entity: ", e);
				}
			} else {
				console.error("I don't understand this key: ", key);
			}
		}
	}
	async performFlagUpdates() {
		const entityTypes = ["actors", "items", "journal", "scenes", "tables"];
		for await (const entityType of entityTypes) {
			switch (entityType) {
				case "scenes":
					// eslint-disable-next-line no-case-declarations
					const sceneData = [];
					for await (const entity of Object.values(
						this.imported.Scene
					)) {
						sceneData.push({
							_id: entity.data._id,
							thumb: entity.data.thumb,
						});
					}
					await Scene.update(sceneData);
					break;
				case "journal":
					// eslint-disable-next-line no-case-declarations
					const journalData = duplicate(
						Object.values(this.imported.JournalEntry)
					);
					for (const journalEntry of journalData) {
						const flag =
							journalEntry.data?.flags[moduleFlag]?.folder.sort;
						if (flag) await journalEntry.update("sort", flag);
					}
					break;
			}
		}
	}
	async checkVersion() {
		const current = game.system.data.version;
		const required = requiredSystemVersion;
		if (current < required) {
			throw Dialog.prompt({
				title: "Version Check",
				content: `<h2>Failed to Import</h2><p>Your Bounty Hunter system version (${current})is below the minimum required version (${required}).</p>
				<p>Please update your system before proceeding.</p>`,
				label: "Okay!",
				callback: () =>
					ui.notifications.warn(
						"Aborted importing of compendium content. Update your system and try again."
					),
			});
		}
	}
	async readManifest(manifestName) {
		const r = await (
			await fetch(`systems/${moduleKey}/${manifestName}`)
		)
			.json()
			.catch((e) =>
				console.warn(
					"MANIFEST ERROR: \nYou likely have nothing in your manifest, or it may be improperly formatted.",
					e
				)
			);
		return r;
	}
	async renderWelcome() {
		setTimeout(() => {
			try {
				game.scenes.getName(sceneToActivate).activate();
				game.journal
					.getName(welcomeJournalEntry)
					.sheet.render(true, { sheetMode: "text" });
			} catch (e) {
				console.error("Couldn't initialize welcome: ", e);
			}
		}, 500);
	}
}
